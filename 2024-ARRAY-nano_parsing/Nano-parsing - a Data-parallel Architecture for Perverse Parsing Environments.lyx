#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass acmart
\begin_preamble

\usepackage{dblfloatfix}
\end_preamble
\options format=sigplan,screen,balance
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding utf8
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "APL385 Unicode"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts true
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype true
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 10
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style ACM-Reference-Format
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 2
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Extended Abstract: Nano-parsing
\end_layout

\begin_layout Subtitle
A Data-parallel Architecture for Perverse Parsing Environments
\end_layout

\begin_layout Author
Aaron W.
 Hsu
\end_layout

\begin_layout Email
aaron@dyalog.com
\end_layout

\begin_layout ORCID
0000-0001-9292-7783
\end_layout

\begin_layout Affiliation
\begin_inset Flex Institution
status open

\begin_layout Plain Layout
Dyalog, Ltd.
\end_layout

\end_inset


\begin_inset Flex City
status open

\begin_layout Plain Layout
Bloomington, IN
\end_layout

\end_inset


\begin_inset Flex Country
status open

\begin_layout Plain Layout
United States
\end_layout

\end_inset


\end_layout

\begin_layout Author
Brandon Wilson
\end_layout

\begin_layout Email
TBD
\end_layout

\begin_layout ORCID
TBD
\end_layout

\begin_layout Affiliation
\begin_inset Flex Institution
status open

\begin_layout Plain Layout
Dyalog, Ltd.
\end_layout

\end_inset


\begin_inset Flex City
status open

\begin_layout Plain Layout
TBD
\end_layout

\end_inset


\begin_inset Flex Country
status open

\begin_layout Plain Layout
Japan
\end_layout

\end_inset


\end_layout

\begin_layout Section*
Abstract
\end_layout

\begin_layout Standard
Traditional parsing literature and design tends to focus on well defined
 grammars over languages that are mostly context free or have contexts that
 require minimal computation that can be reasonably expressed in formal
 notations not designed for general purpose computation.
 [CITATION] The architecture and tooling support that emerges from this
 research and the general community usually comes in the form of parser
 generators, which compile grammars written in a restricted language to
 some implementation such as a parse table or reecursive descent parser;
 parser combinators, which allow the more concise expression of an underlying
 model; or, usually, a recursive descent parser implemented directly in
 the host language, since this often is the most flexible and scalable option
 as complexity increases.
 Context sensitive languages often feel like second class citizens in the
 software engineering parsing ecosystem.
\end_layout

\begin_layout Standard
In our work on static, offline parsing of APL code, the situation is much
 more complex.
 The complexity of the task and the myriad challenges has driven us to coin
 the term 
\begin_inset Quotes eld
\end_inset

perverse parsing environments
\begin_inset Quotes erd
\end_inset

 to describe the situation, since non-trivial context sensitivity is only
 one issue.
\end_layout

\begin_layout Standard
The first issue comes from defining just what APL is as a syntax.
 Since the parser must meet industrial requirements, we cannot simply use
 a reduced language.
 There is no formal specification of the language.
 Worse, there are multiple linguistic variations that must be supported,
 since code migration from one APL implementation to another is a major
 use case for a static parser.
 But it does not stop there, because there is no reference implementation
 of an APL parser either! Extant parsers are woefully incomplete with respect
 to modern APL, and none of them have a meaningful API to permit even basic
 kinds of black box introspection.
 Existing commercial implementations do not implement a static parser, but
 operate on token streams.
 Unfortunately, even the major implementations cannot serve as black box
 reference implementations because of a preponderance of 
\begin_inset Quotes eld
\end_inset

bugs
\begin_inset Quotes erd
\end_inset

 that do not affect every day users, but that do make finding ground truth
 impossible via mechanical means alone.
 This makes the process of writing a parser a fundamentally incremental
 one with frequent introductions of potentially breaking new information
 demanding a resilient parser that can be modified easily at will.
\end_layout

\begin_layout Standard
The second issue comes from the language itself, which exhibits many challenging
 features such as the famous ambiguous phrase: 
\end_layout

\begin_layout Verbatim
A B C
\end_layout

\begin_layout Standard
This expression has well over 10 different parses depending on the types
 of each name.
 But this is only one of the issues; there are more:
\end_layout

\begin_layout Itemize
It is dynamically typed, but parsing depends on the types of variables
\end_layout

\begin_layout Itemize
It mixes dynamic and lexical scope, allowing intermingled function calls
\end_layout

\begin_layout Itemize
Source code makes extensive use of execute/eval constructs, and APL's execute
 primitive can and often does introduce new bindings into various scopes
 while also being sensitive to dynamic and lexical scoping
\end_layout

\begin_layout Itemize
Code bases are often quite flat, with call graphs of high in and out degree;
 that is, many functions will reference many other functions and vice versa
 leading to function dependencies that are many to many with little hierarchical
 segmentation
\end_layout

\begin_layout Itemize
Some syntax errors must be reported at runtime and not at parse time
\end_layout

\begin_layout Itemize
The same core tokens are used to mean different things in different contexts;
 these are the traditional context sensitive parsing problems
\end_layout

\begin_layout Itemize
The context of an expression can amount to the whole program or practically
 the whole program quite easily since an expression's parse may depend on
 distantly defined information
\end_layout

\begin_layout Itemize
Computed goto statements can form the majority of control flow in some functions
, often involving execute/eval
\end_layout

\begin_layout Itemize
Inherent generality and ambiguity can introduce combinatorial factors to
 the size of the parse tree
\end_layout

\begin_layout Itemize
Forward references in the source can alter or affect the parse tree
\end_layout

\begin_layout Standard
These and other more mundane challenges make any traditional parsing architectur
e difficult and cumbersome to use.
\end_layout

\begin_layout Standard
The third major class of issues comes from the context fo the parser itself.
 As an industrial parser, it must address and deal with source in the field,
 and it must integrate with the rest of the Co-dfns [citation] compiler.
 This means it must deliver adequate debugging and source information in
 the AST and it should have excellent and apropos error messages at the
 right stage of compilation.
 Since the whole Co-dfns compiler is meant to self-host on the GPU, the
 parser must execute efficiently on the GPU and CPU.
 It must also perform well when integrated with the APL interpreter (meaning
 that it must execute efficiently under interpretation, and not just compilation
), since it may be embedded into interpreted code.
 Since real APL codebases may have millions of lines of code in them, we
 must handle this.
 Given the high connectedness and combinatorial nature of the AST, this
 means we may need, in effect, the entire source available to us at once
 to parse it correctly, which presents immediate performance challenges.
\end_layout

\begin_layout Standard
The final requirement is the need for an architecture maintainable and scalable
 by a single developer, not a team who can farm out engineering labor such
 as maintaining separate CPU and GPU implementations that are manually synchroni
zed.
 
\end_layout

\begin_layout Standard
To address these concerns, we present a parser architecture deemed Nano-parsing,
 written in APL, and designed to meet the above needs.
 The core strategy of nano-parsing is to traspose the act of parsing from
 a top down, depth-first vision of the tree to a series of data-parallel
 passes over the input that incrementally refines the AST into its final
 form.
 This 
\begin_inset Quotes eld
\end_inset

bottom up
\begin_inset Quotes erd
\end_inset

 approach results in many small, independent blocks of code that represent
 a chain of conceptually functional transformations whose dependencies form
 a loose semi-lattice.
 These passes are implemented in a GPU compatible way in a data parallel
 style of APL.
\end_layout

\begin_layout Standard
Fundamentally, this means that at any point, anywhere in the parser, we
 have full visibility of the global parsing state to use at will.
 Additionally, since the entire parser is a series of extremely simple and
 small passes, we no longer must plan ahead carefully the phases of parsing
 (cut points) that would be needed to handle APL, since these cut points
 fall out naturally from the design.
 Previous attempts at parsing APL using more traditional designs have demonstrat
ed the difficulty in choosing these cut points and the resulting rigidity
 and inflexibility in design that results.
\end_layout

\begin_layout Standard
The nano-parsing architecture possesses the following desirable qualities:
\end_layout

\begin_layout Itemize
It is GPU compatible
\end_layout

\begin_layout Itemize
It decouples error reporting from the act of parsing, allowing errors to
 be dealt with independently
\end_layout

\begin_layout Itemize
It allows arbitrary computation at any point throughout the parsing process,
 such as type inference
\end_layout

\begin_layout Itemize
It is well suited for interpreters that may suffer interpretation overhead
 with traditional methods
\end_layout

\begin_layout Itemize
Its semantics is much easier to understand at scale using code inspection
 because of a linear control flow
\end_layout

\begin_layout Itemize
Since control flows directly from pass to pass, it is easier to see what
 code will be impacted by a change, since all data flows in a single direction
\end_layout

\begin_layout Itemize
The global state and independent passes makes it relatively easy to modify
 a pass or insert new passes without impacting the rest of the code
\end_layout

\begin_layout Standard
We present details of the implementation and the architecture as a whole
 as well as discuss the results of migrating to this new design from a tradition
al PEG parser generator.
 We will highlight some of the ways this design has enabled us to fix issues
 in our pasrsing of APL.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
balance
\end_layout

\end_inset


\end_layout

\end_body
\end_document
